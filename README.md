# Another 85+ Ideas for Computing

This is a list of new ideas since [my last 100 ideas](https://github.com/samsquire/ideas). I hope you enjoy them as much as I did thinking about them and writing them down.

* [Follow me on Twitter](https://twitter.com/mrsamuelsquire)
* You can read this document on Github pages but it might be easier to read [on Github](https://github.com/samsquire/ideas2)
* Please use issues to discuss ideas. Feel free to create issues for any thing you like.
* You don't have to read these ideas in order, you can jump about.
* This is a multipart series, see the [first ideas page, ideas1](https://github.com/samsquire/ideas) and  [third idea page in this series. See ideas3](https://github.com/samsquire/ideas3)

# 1. Digital Contracts and right affirming GUIs

Contracts should be digitised so that anyone on any side of any contract can see what they are responsible for and any actions they can take within the contract. There should be a UI for interacting with the contract. If I have a contract with a company and can legally fetch my private data, I should be able to request that data through the UI. Or if I have a phone contract and I am eligible for an upgrade, I should be able to upgrade through the UI.

Existing:

* [clause](https://clause.io/)
* [monax](https://monax.io/)

# 2. Mobile legal business creation and Personal ERP

Someone with a phone should be able to just create a business that satisfies all reporting requirements and is a legal entity. I want to see a mobile phone app that implements enterprise resource planning for the gig economy.

# 3. Telework

Computational problems can be rendered into labelled graphical video streams upon which people vote. People can then solve computational problems with a television screen, monitor or phone screen by looking at numbered graphs and using a keypad that they enter sequences of numbers into. Problems like efficient scheduling of cars for carpooling or deliveries are solvable by human beings quickly with a user interface that allows one to lasso points on the map and add cars. This is for problems that are not strictly numerical. The goal is to give everyone with a screen, monitor or television a source of income.

# 4. Paper Work Language

We need a way to define work. All work can be represented digitally: take A to B, assemble X with Y. This standard is that a piece of work must fit on an A4 piece of paper. A bit like a job description but each page represents a task. So you have a piece of A4 paper describing one piece of work to do. Each piece of work can depend on other pieces of work. Can be integrated into a continuous integration pipeline for human beings. Work appears in your work inbox.

Existing:

* BPMN Business Processs Modelling Notation
* JBPMN

# 5. Open Demand Mapping and Want marketplaces

People can insert demands for products and services into a demand marketplace within a geographical location. I want a dentist within 5 minutes walk of my home. I want a supermarket within 5 minutes walk of my home. I want to be at work within 10 minutes walk. In aggregate, people create demands on their local areas. This data can be visualised as a smattering of circles around a a central point. The intersecting demands should be surfaced and downloadable where multiple people want the same thing in the same area it should be obvious what satisfies most people's wants.

A want app exposes a market place of wants and allows people to contact others based on their wants. If people published wants accurately and tracked possessions, they could automatically organise swaps with others based on what they want.

# 6. Lifestyle subscriptions

There's a single app for following any dream or any lifestyle with user created content. You pay money per month for some thing you want to do, maybe a lifestyle of healthy eating, eating a certain way, learning a langauge, niche hobby, sports or gym. Maybe you want to become a musician or you want a lifestyle where you live in the suburbs. The company sends you recommended decisions to make, materials and gear that you need for your level of subscription. Users and companies create and maintain lifestyle paths to accommodate every skill level and combination of lifestyle.

So if you said you want a lifestyle where you can get to work within 10 minutes walk, the app would tell you where to move to and who to apply for jobs with. You could subscribe to a coffee everyday. Or if you want to regularly eat out at an upmarket restaurant, you can because your level of subscription includes a set amount of meals a month at a premium restaurant. Can deploy futures to meet demand, such as futures on restaurant tables. Can browse lifestyles in a digital online shop.

[https://lifestyle-subscriptions.com](https://lifestyle-subscriptions.com/)

# 7. Human Query Engine

A filled inbox of questions to answer and questions generated based on my answers to previous questions. Uses random lists of words to ask interesting questions such as "Is **thingA** better than **thingB**" or "Is **thingA** meaningful with **thingB**?" or "How much money do you have in your bank account?". The data collected could be used to implement [life engine](https://github.com/samsquire/ideas#5-life-engine) and can be used to study.
 
Existing:

 * https://Dailydiary.com

# 8. Active Slides

It should be possible to make decisions in a company and run a company via presentation software if slides accurately represent processes of the company and can control a company. Presentation software can be an interactive system. I imagine mobile devices connecting over Wifi. People can run a company via presentation by creating models (flow diagrams) and frameworks (smartart) that are executable by a workflow engines. How companies say they are going to run, is actually how they run. There could be an app store of backend integrations with presentations for showing information that is up-to-date and live; such as pulling in sales data from internal systems and making changes to backend systems.

# 9. Scheduled Society and Virtual Placements

Human suffering could be eliminated if everyone had a virtual placement assigned. Everyone can have what they need and want if every other thing is at the right place at the right time. Place is virtual. There are virtual places such as receive X amount of Y food at Z, shop at X, sleep at X, be at X, receive X, go to X, take A to B, Complete X amount of Y work. Do Y at X time. Everyone has a set of places at any given time. Not everyone needs a virtual place at all times. If virtual places are scheduled, traffic, commuting, waiting can be eliminated. Placement is representation of a position to take in the world - it could be a place in a queue. Everyone can buy and sell placements and schedules. Basically every thing is a market and it can be financialised.

# 10. Library Mesh

Depending on a library could also involve pinging the libraries' software infrastructure so that whenever the library is changed, the dependents are also rebuilt. This would catch code that causes downstream changes to APIs. API changes are expensive.

See [library-mesh repo](https://github.com/samsquire/library-mesh)

Existing:

* [Rust Crater](https://github.com/rust-lang/crater)

# 11. Additive GUIs

GUIs can be declarative. GUIs can be represented as a commutative set of statements. In the form of `widgetA leftOf widgetB`. Represent the commands that generate GUIs as a monotonically increasing set of statements about the GUI and declaratively render a GUI based on propositions of widgets in relationship to one another. Has the property of being able to extend existing GUIs by simply making more statements. See [additive guis](http://github.com/samsquire/additive-guis) Imagine if a set of tweets could render a GUI.

# 12. Recommended music for webpage

Wouldn't it be nice if you could recommend a song to play with a web page as background music. Perhaps a meta tag with a URL to a YouTube video.

# 13. GUIs are queries

The entire GUI could be generatable as response to a query.

A GUI is a two dimensional representation of a multidimensional data structure so a query is a plane slicing a high dimensional data structure.

# 14. User URLs

As the user mouses around the GUI, a URL should be generated which is a representation of what the user is doing at any point in time including all context from the user's perspective. This is like a very deep link into an application, as the user is a resource. See [user urls on github](https://github.com/samsquire/user-urls)

# 15. Free flowing work app

Replace job interviews at individual companies with interviews with an Accreditation app company to vet people for a certain kind of role. People can look at shop exterior and see a logo of an Accreditation  company and work there if they have been vetted by the app. Transport can be branded by Accreditation company and accreditation app companies can specialise in the quality of the people they hire.

# 16. Cloud accelerated desktops

Desktop computers could be accelerated by doing things remotely. If a user's filesystem is mirrored elsewhere, it can be searched remotely and results served locally without incurring any performance penalty locally. See [my cloud desktop repo on github](https://github.com/samsquire/cloud-desktop)

# 17. Data Bento Box

An app that downloads data from various sources online to fill 1 gigabyte of data (reddit, blog posts, articles, free books), implements a viewer and always gives you something to read while you're offline.

# 18. CMS for building webapps

A CMS for webapps: create serverside and clientside routes, register handlers for the server and client side routes, create facts about the GUI.

Would be best integrated with [11. Additive GUIs](https://github.com/samsquire/ideas2/blob/master/README.md#11-additive-guis)

# 19. Stack-upon

The OSI model makes a whole deal of sense, one layer adds promises on-top of the layers below to create an emergent complexity. The network stack manages to offer some very complicated behaviour with the illusion of simplicity at layers above. Each layer makes promises to other layers. What if normal software could take advantage of this property of network stacks by breaking up each responsibility into layers and use wrapped message passing to solve problems.

What if we had a visualization of a multi layered spreadsheet whereby each layer is a layer of the architecture of the software. Instead of formulas calculating an answer, we have message passing between cells that represent promise keepers. So if you wanted a CRUD system, you would send a message to a CRUD service and configure the CRUD service with your messages. You can explore different layers by going up and down the stack whereby the communication between services is at a different layer of messages.

# 20. Credit cards to tap into buildings

Credit cards can be used to access buildings.

# 21. Breakless Software - Depending on Promises

Churn is painful in software development. Things change without warning and things no longer compile or work together. I would like to see a more mature strategy to breaking changes and how they ripple through a software ecosystem. Software change is not cheap. Python 2 to Python 3 is some thing I'd like to avoid going forward. I want to depend on some thing that shouldn't break, that means depending on an abstraction or an interface but is depending on some thing much larger than a single interface in code. I call this depending on a promise. The interface I depend on should not break between major releases, it's stable and it's locked into the software. Javascript in the browser keeps working but my NodeJS, Ruby and Java projects break all the time due to refactoring being done on underlying dependencies. Developers need accurate statistics of code coverage of who is using what. They also need to know if they've broken some thing downstream with their changes.

I propose code coverage tools are used to create snapshots of API usages and aggregated to detect breaking changes.

# 22. Install across

Modern systems such as Elasticsearch, Consul require clusters of computers to install against. What we need is installers that can be configured to install across multiple machines, not just independent machines.

Existing:

* Kubernetes, Helm

# 23. Output text as a changeable interface

Have you ever been looking at the output of a command and wanted to change the output of the command directly? Perhaps it's Kubernetes output or the output of ip a.

You click on a piece of output text, it pops up in an editor and you change it. You then are told what you need to run to make the changed output a reality.

# 24. Programming Language designed for machine refactoring - Refactoring equivalencies

Could a programming language be designed for refactoring simplicity? Java does really well as being a language that supports automated refactorings. I want software breakage caused by refactoring to end. Perhaps the author of a refactoring of a broken signature change could provide an equivalent piece of code that acts as a bridge between the old way of doing a thing and the new way of doing the thing. This way people who upgrade can acquire the code that does the bridge and there is no software breakage.

# 25. Nested Validating YAML Editor

Deeply nested YAML is hard to edit because you do not know what context you're in. If you're modifying Kuberentes YAML, it's hard to know what is valid where. If you indent a block to the left you make the document invalid. Nested YAML editors stop you from indenting to the left by accident. Validating means that the editor tries to deserialize the YAML into the data structure used by the program and shows you that program's interpretation of the input YAML to tell you it's valid or not.

# 26. Web Form field backup

Every thing typed into a web browser should be saved in a new document that is indexed by website. This way we can have an archive of our contributions to any website. With browser synchronization, no data should slip through the cracks. We don't have to worry if a site doesn't permit a backup of our data.

Existing:

 * Lazarus Form Recovery (defunct)
 * Textarea cache
 
 # 27. Call site refactorer
 
 In a system with multiple microservices and use of shared libraries, it is difficult to carry out refactorings across codebases. The call site refactorer is a system that allows refactoring across code bases. It accomplishes this by identifying all uses of a particular signature and then showing every call site in a list. For this to work, automated refactorings must occur against the call site signature. Automated refactorings such as extract variable should work on every call site simultaneously, a bit like multiple cursor support in text editors.
 
# 28. Realistic Runnable Example Driven Documentation

All libraries and systems should be documented by examples. Examples that include import statements, filenames and any other basic precursor knowledge that should be known to run the example to be included so that anybody can run with it. I would argue that Flask and other simple libraries are so successful because they have a simple easy-to-run minimalist example on their home pages.

# 29. Mobile Applications download SQLite databases

Have a lot of data to transfer to a mobile client to create a useful interface? Just send an sqlite database over the wire to seed the client. Then stream updates over HTTP.

# 30. Plain text CRUD

I want an editor that looks like the Github issue editor but renders to plain text - in the format of this idea document and accepts this document as input. So I can click New Idea and have it render to this plain text markdown format.

# 31. Social desktop

I'd like my desktop environment to be social. A desktop shouldn't feel so alone. I want every screen provided by the desktop to have a chat room associated. People can discuss the desktop and vote on things regarding the GUI.

# 32. Community Idea: Does Right & Does Wrong

Ever thought a piece of software did something right? There's no central collection of patterns that are of software done right. I would like to see a website which collects each piece of software's installation process and says what is right about it. Installation process is just an example. There's other things that we can discuss who does something right or wrong.

# 33. Chat bots that ask you randomly generated questions

Like a chat bot that messages you instead of you messaging it. As part of the Human Query Engine.

# 34. Keylogger for personal data collection

Run a key logger that logs data entered into every program on a computer to keep a record of personal data.

# 35. Conversational development

Can software development be done as a conversation? Spin up Docker containers from a chat room. Write SQL. Write JSX React components in chat. Write Redux actions in the chat room. Everyone runs the same code and anyone can make a change anywhere. Without touching a text editor.

# 36. Instanceable Wiki

A wiki that is integrated with a kubernetes or docker swarm environment with pages for various problems. I can simply begin using different kinds of software that I can find via the wiki without an active deployment step. I can surf into some software. The distributed computing page provides implementations and various interfaces for distributed computing that I can use. I can write code that depends on a problem page. Each page is like an API. I should be able to import a page in a programming language.

```
import problem.wiki/a*-algorithm
import problem.wiki/map
map = initialize_map("mapfile")
find_shortest_path(map, "start-position", "goal-position")
```

# 37. Secrets-login and secrets-logout

Store your unavoidable file based secrets in /home/${USER}/secrets and have a shell script called secrets-logout that uses tar and GPG to encrypt your file based secrets when you go home. In the morning, log in with secrets-login to reverse the process.

# 38. Randomly generate your usernames for security

Do not use your name or your personal email address for logging into websites.  Your username is 50% of what's needed to get into your account. Instead, generate a new email alias and use that to login, such as name+1tvsdradv4@example.com.
 
# 39. Instant Ad Purchases

Promises in a digital advert can be directly purchased and appear in a special account with one click. If I see a deal for a product at a certain price, I can click purchase on it and instantly purchase the service or product. You could be driving down a motorway and see an advert for a product on a banner and instantly purchase it with a button on your car wheel. What you're purchasing is the promise specified by the advert. It could be a product at a certain price or more likely, a capability. Each purchase is itself a marketplace as it could be that you're buying from a reseller, you're buying a promise, which means any product that satisfies the promise can ultimately be provided to you.

# 40. Ticketless travel

A ticket is for saying where you're trying to go, not that you've paid. Ticketless travel is possible through credit cards loaded with digital tickets and NFC.

# 41. Conveyor belt GUI

Imagine if a web request response had to be constructed by a human being. The incoming request sits on a queue. The UI has conveyor belts that take relevant information to the human operator. The human operator interacts with these request objects and constructs a response object

# 42. Depend on language feature

A programming language whereby you import language features to depend upon. Python has a PEP process and Java has JSRs. You directly depend on named groups of functionality and this determines your language experience. Perhaps the fist line of the file after the shebang says what language features to enable, such as "feature1,feature2,feature3"

# 43. World splitting app

Territories can be occupied by people who believe in the same things. If enough people used an app and voted for what they wanted on the app and agreed to move towards where other people believe the same things, people could begin to get what they want. This idea is called world splitting because you divide the world in half when you agree with a policy.

# 44. General Thing Object Editor

A general purpose CRUD editor with the flexibility and power of a file explorer.

# 45. One giant JSON structure

Can the state of an organisation be ran as a giant JSON structure?

# 46. Migrationless CMS

Headless CMSes such as Strapi require expensive migrations to keep up-to-date. I'd like a CMS that promises to be compatible from early versions with minimal impact.

# 47. Single file visualized as a directory

Take a single file with special comments to delineate directories and render in an editor as a folder with multiple files.

# 48. Continuous deployment integrated into the desktop

Titlebar of running applications reflects state of an upcoming build of the same application that is being compiled on CI.

# 49. Stateful workstation

When I open a number of programs, I would like this list of programs to be persisted so that I can shut down the computer and return to them again. I'd like the same for the terminal too.

Existing:

* Tmuxinator

# 50. Empty space scheduler

The ability to schedule disk space to various purposes and to schedule files to different regions of empty space. I have three hard drives My virtual disks in my VMs should also resize (to grow) automatically.

# 51. Tips should be crowdsourced

When an application wants to show a tip, it should be crowdsourced.

# 52. Digital open source organisation

Open source community could come up with an organisation that is digital and runs every thing via code.

# 53. Open source customer service application

Integrate with chatops and case management ops to offer jobs to people on mobile phones to do customer support via chat.

# 54. An IDE that guarantees buildability

An IDE that guarantees if you can open the project, you can build it reliably the way others build it. Dependencies are fetched.

# 55. Generalized API client

Like CURL but for querying APIs and handling pagination for you.

# 56. Deep GUI

Every form of information collected by a corporation to go to a GUI server whereby data forms can be monitored and centrally tested.

# 57. Stream/Pipeline editor

Another program in an Office suite: An editor for streams, such as Bash pipelines or Kafka streams. Would allow you to replay data between points in the pipeline and test each stage independently.

# 58. Desktop Advertising

What can your computer do for you? The operating system and IDE advertises features and things it can do based on what is installed.

# 59. Personal Message Bus

My computer and software I interact with raises events all the time. I'd like to be able to hook into events that are raised and add behaviour to them.

# 60. Asynchrony editor

An interface to create asynchronous tasks definitions. I'm thinking of complicated workflows in the backends of controllers whereby multiple services need to be contacted and queried and where there are complicated error handling.

# 61. Resource scheduling

A office suite application for allocating resources to problems.
 * Schedule SSH keys and schedule public keys to be in different locations in a network.
 * Schedule files to be present on certain servers.
 * Schedule people in a company to receive things.

# 62. Work by mobile phone

People should be able to do work via a mobile phone and be paid for it. We need to convert problems to be runnable by mobile phone.

# 63. Title Finder - Vote on the division of work

People with the same title do different things. We could decentralize by voting what tasks constitutes a newly named role and eliminate burnout by creating accurate titles. We could identify who does most of the work in society.

# 64. Crowd database that doesn't break between releases

Imagine a database of personal information, facts about yourself and various collected resources. I want to crowd source queries to this database to create interesting GUIs and for the data in the database not to require manual migrations. Development should always be carried out with an example dataset, so developers do not get used to started from empty all the time.

# 65. Automate job descriptions

We can automate job descriptions by building GUIs and workflow rule engines.

# 66. Open source food ordering

Ordering food could be a commodity like web server software. We need an open source food ordering platform.

# 67. Stem cell servers and communication libraries for monolith to microservice

Monoliths can be stem cell servers - they can startup and choose what kind of servers to be. When software needs to communicate with a service boundary, it should go through a library. The library is configured to transform requests into either method calls, REST calls or MQ messages based on configuration to talk to other deployed instances of the service.

Communication libraries can be configured with retry logic and circuit breakers.

# 68. Web based system GUIs

Use a web interface to render desktop environment screens.

# 69. IT design software

Active network design software. Build a cloud network with a network designer GUI and render to Terraform or cloud API calls.

# 70. Work spreadsheet

I want to allocate computing resources to different purposes. I'd like a GUI like spreadsheet that lets me allocate work to different CPUs and to different machines perhaps running containers.

# 71. Community Idea: Workloads

My computer has lots of spare resources. My computer is powerful enough to run demanding applications because it is multicore. What my computer needs is models that take resources to run. I'd like a community of people generating workloads for computers to run.

# 72. Task Store

There should be a menu in a desktop that is like a search for a task. So if you want to add numbers, you might be guided towards a spreadsheet. A shop of things that people can do with their computers. Not necessarily apps but the interoperation of multiple services installed to create some behaviour. For example, you could be guided through the process to create a website and then the following things happen:

```
    "Now you have a website, the following tasks are open to you"
     * Password Protect my photo album
    "Now you have a database, the following tasks are open to you:"
     * Setup [Accounts]
    "Now you have a virtual network you can set up the following useful programs"
     * File [Synchronization]
```

I can search for ways of doing things, such a search for "track spending" and then I am introduced to someone's technical solution to this problem which is to show forms that collect spend amounts. If I don't like this approach, I can try another one. The line between software installation and use of someone's software is blurred.

# 73. Personal overlay network (VPN)

My phone should be contactable via my desktop and by my laptops.

Existing:

* Hamachi

# 74. Community idea: System Administration

A reddit or forum like website for managing large fleets of servers in a peer to peer driven way. Each post represents an administration task or some thing that can be executed on a server such as an Ansible task. For example, in the backup part of the website, there's a post for beginning a general system backups and a nested tree of actual backups. There's a post for each system resource such as listening ports and active connections. 

Create machines in the cloud as easily as creating a post.

# 75. Community Idea: Optimist community

A community of thoughts around "wouldn't it be nice if".

See my repository https://github.com/samsquire/society for an optimistic view of the future.

# 76. Configuration Trialler

A tool that either generates configuration files or command line options to try out different combinations of configuration options together. Use a hill climbing algorithm to see how each option affects run time performance or some other property of the system such as file size or safety. I had such a script that experimented with compression and encryption options of GPG but I have since lost it.

# 77. Devops Data Flow Model and Execution

Model dataflow between infrastructure provisioning tools such as Terraform, Ansible, Packer, Kubernetes and execute the resulting graph in parallel.

See devops-pipeline https://github.com/samsquire/devops-pipeline

# 78. CSV with embedded YAML to Cloud/Containers

CSV of VMs/images to spin up in the cloud.

# 79. Nested spreadsheets

Embed a sub-spreadsheet in a row.

# 80. Distributed Assertions

Log rich data structures and assert across the data structures that were logged by each machine. Could be used to test distributed systems. Use Complex event processing (CEP) to do unit tests across logs.

# 81. Structured Logging Based Development

Write an end-to-end flow example log for your software and assign what machines carries out which log line so that communication between machines can be inferred by log entries by jumping between machines. For example, the following log definition CSV handles registration whereby the server contacts the email service to send an email.

```
Registering user :username,server
Sending verify email,emailservice
Handling order,orderservice
Generating invoice,invoiceservice
```

The log lines act as an interface to implement against and automatically pass context information automatically to the next service.

See https://github.com/samsquire/structured-logging-2-system

# 82. New Environment by Name

The ability to create a new environment by changing a single string. See devops-pipeline https://github.com/samsquire/devops-pipeline

# 83. Right click Use

Use things that are on the screen by right clicking on them and selecting 'Use'.

# 84. Communication Code Slices

Slice a block of contiguous code up and specify where each slice should run using comments. Introduces implicit communication calls to convey context data through the code. Write one program and split it up between servers via communication slices. You specify where each side should run, on the client, on a server or in a microservice.

```
# server /login
login_request = Request()
password = login_request.get("password")
username = login_request.get("username")
hashed_password = bcrypt.hash(password)
users = db.users.find(username=username, hashed_password=hashed_password)
if users:
   response = make_response(redirect('/'))
   response.set_cookie('session_id', s.session_id)

# server /
feed_items = db.feed.find(username=username)
response = make_response(render_template('feed.html', items=feed_items))

# clientside /feed
recommendation_service.fetch_recommendations()
recent_posts_service.fetch_recent_posts()

# recommendation_service /recommendations
recommended_items = db.recommendations.find(username=username)
response = make_response(render_template('feed.html', items=recommended_items))

# recent_posts_service /recent_posts
recent_items = db.recents.find(username=username)
response = make_response(render_template('feed.html', items=recent_items))

```

# 85. Threadsheets

A spreadsheet of objects, rather than numerical cells. The code for a web application can live in a cell and communication to database and other services can be threaded through different cells. Would have a GUI where each cell can act like a REPL to your database, ORM system and CLI.

# 86. Stationary Reader

A reader that you can keep open on a monitor while eating without any mouse or keyboard input and it shows content and scrolls through content.

# 87. Personalised Advice Stream

With data from the Human Query Engine and user generated opinions, we can produce highly personalised advice for people in the form of notifications in an advice feed. The advice should be highly personalised based on previous answers.

# 88. Spaced repetition feed

Take surfed pages and turn them into a spaced repetition feed.

# 89. Decision software

When you need to make a decision, you open a program in your office suite called Decision. You fill out what needs to be decided and file it in a system. The people who need to approve the decision can do so as they get notified. Automated decisions based on rules can be defined.

# 90. Achievable things my computer can do for me while idle

My CPU has 64 threads in order to do things in parallel. I am looking for things I can use my CPU for.

1. Path finding algorithm
2. Semantic Reasoning
3. Compiling
4. Running test builds (with coverage)
5. Packaging up Linux distributions with packages pre-installed
6. @Home projects like Folding@Home, SETI@Home

# 91. Idea collection

Ideas that are not large enough for their own section.

* **Baked in development environments** A Linux distribution could come with a working development environment already configured to write applications in.
* A package manager for Nginx files. Installs different virtual hosts with different server names for hosting multiple apps on the same nginx server
* **Community Idea: GUI Vote**: Vote what should be visible in a GUI screen. Used to implement a [drill-down interface](https://github.com/samsquire/ideas#41-drill-down-interface).
* **Data structure browser** Browse trees, lists and other data structures being used to render GUIs or programs.
* **Entrypoints folder** Every source repository should have an entrypoints folder whereby the various entry points for the application is obvious.
* **Download and install simultaneously** When downloading multiple packages, Apt-get currently downloads, then installs. It could run a download and installation in parallel.
* **Content for Desktop environments** Desktops should be filled with content to browse and peruse.
* **Messaging Topology format** It would be nice if messaging systems supported a generic format for creating a messaging topology. For publish/subscribe and distribution lists.
* **Single file GUI** A GUI format that bundles rendering information with data queries.
* **Digital magazines** A personal computer inbox of automatically updating magazines about your machine. For example, you'll receive a disk space magazine which shows how disk space is being used in the same format as SequoiaView. 
* **Community Idea: Secret Sauce** Understand what a project does by looking at what API calls a piece of software uses. The secret sauce of Kubernetes is that it runs Docker run for you.
* **Visual package manager** Cards to represent each package. Example use in the cards.
* **Write code single threaded and single host synchronously execute and multihost multithreaded asynchronously** Write code as if it executes as a single thread of communication.
* **Data flow control** Flow control implemented from the database through to the frontend for suction of data.
* **Preserving window manager and desktop environment codebase purity** There are some ideas that require interaction between the desktop manager and the window manager but we do not want to pollute any of these codebases by crossing the boundary. We can instead run a daemon and have a daemon and a network call to implement integrations across 
* **Design language mapping** Write your application to one design language. When a new design language comes out, someone writes a mapping between the old design language to the new language. So that people get design upgrades for free.
* **Community Idea: Digestible documents** Complicated documents distilled to Tweets that you can consume at your own pace.

# 92. GUI Thunks

Operations can be visually queued by interacting with objects that represent a pending operation as if it had been completed.
See https://github.com/samsquire/gui-thunks

# 93. Distributed spreadsheets

Spreadsheets that run across multiple machines for performance and parallelism. Cells can be configured to come from other computers.

# 94. Spreadsheet web designer

A development server that can be the destination of any web form. Using the primitives map, filter, reduce, a spreadsheet that lets you see incoming data and transform it into a web page.

# 95. Open database as spreadsheet

Spreadsheets are helpful views of data. Can open a database with a spreadsheet viewer and convert spreadsheet formulas into SQL.

# 96. Data structure configurer

A language where you can request properties of your data structure to select an implementation. This could enhance [cost aware computing](https://github.com/samsquire/ideas#43-cost-aware-computing).

Imagine needing to import a sort algorithm, I can pass properties to the import command such as needing to import a sort algorithm that doesn't care about stable sorting and can deal with partially presorted data:

```
import "sort" stable=true partiall_sorted=true n=50000
```

# 97. Telemetry enabled desktop

Every UI container should be tracking how many items are inside it. From this data we can decide what data structures and widgets to use for every UI widget on the screen. From this we can collect:

* View performance (timings)
* View lifetimes
* View recycling
* Bitmap caching
* View invalidation
* Flamegraphs
* Performance profiling

# 98. Business cloud

A marketplace of business space, business services, employment, products and services that can be provisioned by data and code through the commodisation of all business plans so that real life businesses can be created by software. Schedule people, buildings, vehicles from one central place.

A coffee shop can be represented as code and data structures and the systems needed to provision a coffee shop should be provisionable by code.

# 99. Deep Lever & Action at distance

I am still working on this idea.

Imagine you have a very long lever, you can cause action at a distance. Deep Lever means to use a data structure to drive out behaviour far from where the data structure is defined to exert control over it. Examples:

 * You're an operating system company and you have a desktop application or an office application. Every dialogue, menu should be catalogued in a CMS for those things. So you can manage shortcut keys centrally and generate documentation easily.


https://github.com/samsquire/ideas#53-web-state-machines-for-testing

# 100. Data shape changer

Have a table of data? Use Pivottables to change the shape of the data until it is convenient to process.

# 101. Declarative GUIs

A GUI that is a live system that takes declarative rules of what should be where.

Every thing on the screen originates from streams that have been mapped and filtered.

# More ideas

There's [more ideas in ideas3](https://github.com/samsquire/ideas3).
